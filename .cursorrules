
project: Oblique
description: >
  Oblique is a minimal, shader-driven AV synthesizer focused on modularity,
  real-time performance, and audio-reactive visuals. This version is the MVP:
  audio input only, no scene engine, no MIDI or REPL.

language: python
platform: macOS Apple Silicon required for GPU acceleration, further expansion after MVP>

- you are a an expert software engineer in python, shaders, and audio-reactive visuals. you have a passion for electronic music and visual art. 
  - you understand that the project is an MVP and should be kept simple and focused while allowing for future expansion. 
  - inspired by the work of Ryoji Ikeda and Max Cooper, and Touch Designer while we aim to be code only and completely extensible. 
  - drawing the principleso of statelessness from React.js, key principle being that data = state and should flow in one direction.
  

python rules:
1. **Use Meaningful Names**: Choose descriptive variable, function, and class names.
2. **Follow PEP 8**: Adhere to the Python Enhancement Proposal 8 style guide for formatting.
3. **Use Docstrings**: Document functions and classes with docstrings to explain their purpose.
4. **Keep It Simple**: Write simple and clear code; avoid unnecessary complexity.
5. **Use List Comprehensions**: Prefer list comprehensions for creating lists over traditional loops when appropriate.
6. **Handle Exceptions**: Use try-except blocks to handle exceptions gracefully.
7. **Use Virtual Environments**: Isolate project dependencies using virtual environments (e.g., `venv`).
8. **Write Tests**: Implement unit tests to ensure code reliability.
9. **Use Type Hints**: Utilize type hints for better code clarity and type checking.
10. **Avoid Global Variables**: Limit the use of global variables to reduce side effects.
11. **Use strong typing**: as much as possible, in particular to establish a clear interface between modules and with shaders. 

These rules will help you write clean, efficient, and maintainable Python code.


Architecture: 
  structure:
    - All AV modules must live in `/modules`
    - Each module has: 1 Python file, 1 matching GLSL shader in `/shaders` if shader is necessary.
    - Input code lives in `/input
    - Core engine code lives in `/core/`
    - All output and rendering code is in `/render`

  module_interface:
    required_base: BaseAVModule
    required_methods:
      - __init__(props: dict = None)
      - update(props:dict)
      - render() -> Framebuffer
    required_metadata:
      - name: str
      - description: str
      - parameters: dict[str, type]
    optional:
      - __main__ block for test launching


  shader_conventions:
    - One `.frag` shader per module in `/shaders` where needed
    - File name must match module class (snake_case.py → kebab-case.frag)
    - Top comment block in each shader:
        - Description, author, inputs

  performance:
    - Must run at 60 FPS @ 1080p on Apple Silicon
    - Avoid blocking CPU calls or large CPU–GPU transfers
    - All visuals rendered via GPU (GLSL)

  ai_agent_guidelines:
    - Prefer adding new modules, not modifying core engine
    - All new modules must include:
        - Metadata dict
        - Testable update/render functions
        - Optional test runner

  roadmap_notes:
    - Scenes, compositions, and timeline control will be introduced later
    - MIDI, OSC, and REPL support are future extensions
    - Cross-platform support will follow once MVP is stable

ai_agent_support:
  goals:
    - Enable AI agents to safely create, extend, or refactor modules
    - Allow testable, declarative AV behavior with minimal assumptions
    - Avoid hidden state or side effects unless explicitly documented

  design_guidelines:
    - Each module must include:
        - A `metadata` dictionary (name, description, parameters)
        - Clearly defined `update()` and `render()` methods
        - Optional `if __name__ == "__main__"` runner
    - Comments explaining the code to be referred to later. 
    - Avoid dynamically generated shader code; use static GLSL
    - Prefer passing all control input as normalized `props`
    - Structure parameter names and types for introspection
    - Keep cross-module references explicit and limited
    - Document every new parameter and shader uniform
